from argparse import ArgumentTypeError
from datetime import datetime
from importlib import import_module
import re
import os.path

from django.apps import apps
from django.core.management.base import BaseCommand
from django.db.migrations.loader import MigrationLoader
from django.utils.module_loading import module_dir


EXPR_RE = re.compile(r'(\w+)\.(\w+)\.(\w+)')


def stored_expr(value):
	match = EXPR_RE.fullmatch(value)

	if match is None:
		raise ArgumentTypeError('invalid format')

	app, model, field = match.groups()

	try:
		field = apps.get_app_config(app).get_model(model)._meta.get_field(field)
	except Exception as e:
		raise ArgumentTypeError(str(e))

	if not hasattr(field, '_binder_stored_expr'):
		raise ArgumentTypeError(f'{field.model.__name__}.{field.name} is not a stored expr')

	return field


def value_to_string(expr):
	if not hasattr(expr, 'deconstruct'):
		return repr(expr), set()

	parts = []
	modules = set()

	name, args, kwargs = expr.deconstruct()
	module = name.rpartition('.')[0]

	parts.append(f'{name}(')
	modules.add(module)

	first = True

	for value in args:
		if first:
			first = False
		else:
			parts.append(', ')

		substring, submodules = value_to_string(value)
		parts.append(substring)
		modules.update(submodules)

	for key, value in kwargs.items():
		if first:
			first = False
		else:
			parts.append(', ')

		substring, submodules = value_to_string(value)
		parts.append(f'{key}={substring}')
		modules.update(submodules)

	parts.append(')')

	return ''.join(parts), modules


class Command(BaseCommand):

	def add_arguments(self, parser):
		parser.add_argument(
			'exprs', type=stored_expr, nargs='+',
			help='stored exprs to autofill',
		)

	def handle(self, exprs, **kwargs):
		for expr in exprs:
			app = expr.model._meta.app_config

			loader = MigrationLoader(None, ignore_no_migrations=True)
			conflicts = loader.detect_conflicts()

			assert not conflicts
			leaves = loader.graph.leaf_nodes(app.label)
			assert len(leaves) <= 1

			migrations_module, _ = MigrationLoader.migrations_module(app.label)
			migrations_dir = module_dir(import_module(migrations_module))

			if leaves:
				number = int(re.match(r'\d+', leaves[0][1]).group()) + 1
			else:
				number = 1

			migration_path = os.path.join(migrations_dir, f'{number:>04}_autofill_{expr.model.__name__}_{expr.name}'.lower())
			expr_string, modules = value_to_string(expr._binder_stored_expr)

			with open(migration_path, 'w') as f:
				f.write(f'# Generated by Django Binder on {datetime.now():%Y-%m-%d %H:%M}\n')
				f.write('\n')
				f.write('import django.db.migrations\n')
				for module in modules:
					f.write(f'import {module}\n')
				f.write('\n')
				f.write('\n')
				f.write('def autofill(apps, schema_editor):\n')
				f.write(f'    {expr.model.__name__} = apps.get_model({app.label!r}, {expr.model.__name__!r})\n')
				f.write(f'    {expr.model.__name__}.objects.update({expr.name}={expr_string})\n')
				f.write('\n')
				f.write('\n')
				f.write('class Migration(django.migrations.Migration):\n')
				f.write('\n')
				if leaves:
					f.write('    dependencies = [\n')
					for dep in leaves:
						f.write('        {dep!r},\n')
					f.write('    ]\n')
				else:
					f.write('    initial = True\n')
					f.write('\n')
					f.write('    dependencies = []\n')
				f.write('\n')
				f.write('    operations = [\n')
				f.write('        django.migrations.RunPython(autofill, migrations.RunPython.noop),\n')
				f.write('    ]\n')
